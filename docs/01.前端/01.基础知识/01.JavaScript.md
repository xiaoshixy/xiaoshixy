---
title: JavaScript基础
date: 2022/06/06
categories: 
  - 前端
  - 基础知识
tags: 
  - 前端
  - JS
permalink: /pages/js/
author: 
  name: xiaoshi
  link: https://github.com/xiayuan-001
---

## JS 组成

ECMScript 【语法】

DOM 【页面文档对象】

BOM【浏览器对象模型】

## JS 输入输出语句

- 输入

```javascript
prompt('请输入你的年龄')
```

- 弹窗

```javascript
alert('计算的结果是')
```

- 输出

```javascript
//控制台输出
console.log('我是程序员能看')
```

## 变量

- 变量初始化

```javascript
var myname = 'xy'
```

- 声明多个变量

```javascript
var age = 18,
  addr = '火影村',
  gz = 2000
```

- 只声明不赋值

```javascript
var sex
console.log(sex) //undefined
```

## 数据类型

### Number

- 进制

```javascript
// 数字型
var num = 10
var PI = 3.14
// 八进制 0~7 数字前加0 表示八进制
var num1 = 010
console.log(num1) //010 八进制 转换 10进制 8
var num2 = 012
console.log(num2)
// 十六进制 0~9 a~f #ffffff 数字的前面加 0x 表示十六进制
var num3 = 0x9
console.log(num3) //9
var num4 = 0xa
console.log(num4) //10
```

- 最大值

```javascript
console.log(Number.MAX_VALUE) //1.7976931348623157e+308
```

- 最小值

```javascript
onsole.log(Number.MIN_VALUE)
```

- 无穷大

```javascript
console.log(Number.MAX_VALUE * 2) //Infinity
```

- 无穷小

```javascript
console.log(-Number.MAX_VALUE * 2) //-Infinity
```

- NaN

```javascript
console.log('xy' - 10) //NaN 无法计算
```

- isNaN

```javascript
// isNaN 判断非数字 是数字 返回false 非数字 返回true
console.log(isNaN(12)) //false
console.log(isNaN('xy')) //true
```

### String

- 引号【嵌套】

```javascript
// 外双内单 外单内双
var str = '我是"一个"好人'
console.log(str)
```

- 转义字符【换行\n,缩进\t】

```javascript
// 字符串转义字符 用\开头 必须包含在引号里
var str = '我是"一个"\n好人'
```

- 检测字符串长度

```javascript
var str = 'my name is andy'
console.log(str.length)
```

- 字符串拼接**【数值相加+字符相连】**

```javascript
// 字符串拼接 字符串+任何类型=拼接之后的新字符串
console.log('xy' + 'haoren')
console.log('pink' + 18)
console.log('pink' + true)
console.log(12 + 12)
console.log('12' + 12)
```

- 字符串拼接加强

```javascript
var age = 18
//变量和字符串相连口诀： 引引加加
console.log('pink' + age + '岁')
```

### Boolean

- 参与运算

```javascript
var flag = true
var flag1 = false
console.log(flag + 1) //参与加法运算 当1来看
console.log(flag1 + 1) //参与加法运算 当0来看
```

### Undefined

```javascript
//如果一个变量声明未赋值 undefined 未定义数据类型
var str
console.log(str)
var variable = undefined
console.log(variable + 'pink') //undefinedpink
console.log(variable + 1) //NaN  undefined 和数字相加 最后结果是 NaN
```

### Null

```javascript
//null
var space = null
console.log(space + 'pink') //spacepink
console.log(space + 1) //1
```

## 获取数据类型

```javascript
var str = 'pink'
console.log(typeof str) //string
```

## 转换为字符型

```javascript
//数字型转换为字符串 变量.toString()
var num = 10
var str = num.toString()
console.log(str)
console.log(typeof str)

//利用 String(变量)
console.log(String(num))

// 利用 + 拼接  隐式转换
console.log(num + '')
```

## 转换为数字型

- parseInt

```javascript
// parseInt(变量)  字符型转为数字型 得到的是整数
var age = prompt('输入你的年龄')
console.log(parseInt(age))
console.log(parseInt('3.14')) // 3 取整
console.log(parseInt('3.94')) // 3 取整
console.log(parseInt('120px')) //120 去掉px单位
console.log(parseInt('rem120px')) //NaN
```

- parseFloat

```javascript
//parseFloat(变量)  字符型转为数字型 得到的是小数
console.log(parseFloat('3.14')) //3.14
console.log(parseFloat('120px')) //120 去掉px单位
console.log(parseFloat('rem120px')) //NaN
```

- Number

```javascript
var str = '123'
console.log(Number(str))
console.log(Number('12'))
```

- 算数运算

```javascript
// 利用算数运算 - * / 隐式转换
console.log('12' - 0)
```

## 转换为 Boolean 型

```javascript
//以下5种均为false 其余为true
console.log(Boolean('')) //false
console.log(Boolean(0)) //false
console.log(Boolean(NaN)) //false
console.log(Boolean(null)) //false
console.log(Boolean(undefined)) //false
```

## 算数运算符

- % 取余

```javascript
console.log(5 % 3) //2
console.log(3 % 5) //3
```

- 浮点数

```javascript
//浮点数 算数运算会有问题 精度问题
console.log(0.1 + 0.2) //0.30000000000000004
console.log(0.07 * 100) //7.000000000000001
//不能直接用浮点数相比较 是否相等
var num = 0.1 + 0.2
console.log(num == 0.3) //false
```

## 前置递增运算符

- **口诀：先加 1 后返回值**

```javascript
var p = 10
console.log(++p + 10) //21
```

## 后置递增运算符

- **口诀：先返回原值 后自加 1**

```javascript
//前置与后置自增单独使用 效果一样
//口诀：先返回原值 后自加1
var age = 10
console.log(age++ + 10) //20
console.log(age) //11
```

- 练习

```javascript
var c = 10
c++ //c++ 11 c=11
var d = c++ + 2 //c++ =11  c = 12 先原值返回 再自加1
console.log(d) //13

var e = 10
var f = e++ + ++e //1.e++ = 10  e=11 2.e =12 ++e=12
console.log(f) //22
//后置自增 先表达式返回原值 后面变量再自加1
```

## 比较运算符

- 大于等于

```javascript
console.log(3 >= 5) //false
```

- 判断等于 ==

```javascript
// 程序里面等于符号是 == 默认转换数据类型 会把字符串数据转换为数字型[隐式转换]
console.log(18 == '18') //true
console.log(18 != 18) //false
```

- 全等 ===

```javascript
//程序里全等 === 一模一样 两侧值 数据类型 完全一致
console.log(18 === 18)
console.log(18 === '18')
```

## 逻辑运算符

- 逻辑与

```javascript
console.log(3 > 5 && 3 > 2) //false
console.log(3 < 5 && 3 > 2) //true
```

- 逻辑或

```javascript
console.log(3 > 5 || 3 > 2) //true
console.log(3 > 5 || 3 < 2) //false
```

- 逻辑非

```javascript
console.log(!true) //false
```

## 短路运算

- 逻辑与 短路运算
  - **表达式 1 结果为真, 返回表达式 2;表达式 1 结果为假,那么返回表达式 1**

```javascript
//逻辑与 短路运算
console.log(123 && 456) //456
console.log(0 && 456) //0
// 如果有空的或者否定的为假 其余是真的 0 '' null undefined NaN
console.log(0 && 1 + 2 && 456 * 7895) //0
console.log('' && 1 && 234 * 555) //''
```

- 逻辑或 短路运算

```javascript
//逻辑或短路运算  如果表达式1 结果为真，则返回表达式1；如果表达式1 结果为假，则返回表达式2
console.log(123 || 456) //123
console.log(123 || 456 || 789) //123
console.log(0 || 456 || 456 + 123) //456
```

## 赋值运算符

```javascript
var age = 2
age *= 10 //age = age * 10
console.log(age)
```

## 运算符优先级

- 一元运算符里面的逻辑非优先级很高
- 逻辑与比逻辑或优先级高

## if 语句

- if 分支语句

```javascript
//执行思路 if 条件表达式为真 则执行大括号里面的 if 条件表达式为假 则不执行大括号
if (3 > 5) {
  alert('沙漠骆驼')
}
```

- **if 双分支语句**

```javascript
//执行思路 如果表达式结果为真 那么执行语句1 否则 执行语句2
var age = prompt('请输入您的年龄:')
if (age >= 18) {
  alert('我想带你去网吧')
} else {
  alert('回家做作业')
}
```

```javascript
var year = prompt('请您输入要检测的年份:')
if ((year % 4 == 0 && year % 100 !== 0) || year % 400 == 0) {
  alert(year + '是闰年')
} else {
  alert(year + '是平年')
}
```

- **if else if 语句（多分支语句）**

```javascript
//伪代码 按照从大到小思路
var grade = prompt('请输入分数:')
if (grade >= 90) {
  alert('等级是：A')
} else if (grade >= 80 && grade < 90) {
  alert('等级是：B')
} else if (grade >= 70 && grade < 80) {
  alert('等级是：C')
} else if (grade >= 60 && grade < 70) {
  alert('等级是：D')
} else {
  alert('等级是：E')
}
```

## 三元表达式

- 简化的 if else

```javascript
//三元运算符组成的式子 三元表达式
//++num 一元 3 + 5 二元  ? :
// 条件表达式? 表达式1 ： 表达式2
//执行思路
// 如果条件表达式结果为真 则返回 表达式1的值 否则 返回表达式2的值
var num = 10
var result = num > 5 ? '是的' : '不是的' //表达式有返回值的
console.log(result)
```

## switch 语句

- 开发里面 表达式经常写成变量

```javascript
var num = 3
switch (num) {
  case 1:
    console.log(1)
    break
}
```

- **num 的值 和 case 里面的值相匹配的时候 是全等 必须是值和数据类型一致的时候 num === 1**
- **break 如果当前的 case 里面没有 break 则不会推出 switch 继续执行下一个 case**

```javascript
//利用表达式的值 和 case 后面选项值相匹配 如果匹配上 就执行该case里面的语句 如果都没匹配上，那么执行default里面的语句
switch (2) {
  case 1:
    console.log('这是1')
    break
  case 2:
    console.log('这是2')
    break
  case 3:
    console.log('这是3')
    break
  default:
    console.log('没有匹配结果')
}
```

- 案例

```javascript
// 用户在弹出框里面输入一个水果，如果有就弹出该水果的价格， 如果没有该水果就弹出“没有此水果”。
var fruit = prompt('请输入您查询的水果:')
switch (fruit) {
  case '苹果':
    alert('苹果是3.5元/斤')
    break
  case '榴莲':
    alert('榴莲是35元/斤')
    break
  default:
    alert('没有此水果')
}
```

## for 循环

- 语法结构

```javascript
//for 循环 重复执行某些代码 通常跟计数有关系
//for 语法结构
//初始化变量 就是用var 声明的一个普通变量 通常用于作为计数器使用
//条件表达式 就是用来决定每一次循环是否继续执行 就是终止的条件
//操作表达式 就是每次循环最后执行的代码 经常用于计数器变量进行更新（递增或递减）

for (初始化变量; 条件表达式; 操作表达式) {
  //循环体
}
```

- 执行过程

```javascript
//首先执行里面的计数器变量  var i = 1  在for只执行一次 index
//i <= 100 来判断是否满足条件 如果满足条件 就去执行循环体 不满足条件 退出循环
//最后去执行 i++ i++是单独写的代码 递增
//接着去执行i <= 100 如果满足条件 就去执行循环 不满足 退出循环

for (var i = 1; i <= 100; i++) {
  console.log('你好吗')
}
```

- 执行相同代码

```javascript
//for循环执行相同的代码
for (var i = 1; i <= 10; i++) {
  console.log('love dive')
}

//可以让用户控制输出的次数
var num = prompt('请您输入次数:')
for (var i = 1; i <= num; i++) {
  console.log('tomboy')
}
```

- 执行不同代码

```javascript
//for 循环执行不同代码  i的存在 每次循环 都会变好
//输出一个人1~100岁
for (var i = 1; i <= 100; i++) {
  console.log('这个人今年' + i + '岁')
}
//嵌套if语句
for (var i = 1; i <= 100; i++) {
  if (i == 1) {
    console.log('这个人今年出生了')
  } else if (i == 100) {
    console.log('他死了')
  } else {
    console.log('这个人今年' + i + '岁')
  }
}
```

- 重复执行某些操作

```javascript
// 求1-100所有整数累加和
//         需要循环100次，我们需要一个计数器  i
// 我们需要一个存储结果的变量 sum ，但是初始值一定是 0
// 核心算法：1 + 2 + 3 + 4 ....   ，sum  =  sum + i;
var sum = 0
for (var i = 1; i <= 100; i++) {
  sum = sum + i
}

console.log(sum)
```

### for 循环案例

```javascript
// 求1-100之间所有数的平均值
var sum = 0
var avg = 0
for (var i = 1; i <= 100; i++) {
  sum = sum + i
}
avg = sum / 100
console.log(avg)
```

```javascript
// 求1-100之间所有偶数和奇数的和
var even = 0
var odd = 0
for (var i = 1; i <= 100; i++) {
  if (i % 2 == 0) {
    even = even + i
  } else if (i % 2 == 1) {
    odd = odd + i
  }
}
console.log('1~100所有偶数和是' + even)
console.log('1~100所有奇数和是' + odd)
```

```javascript
// 求1-100之间所有能被3整除的数字的和
var sum = 0
for (var i = 1; i <= 100; i++) {
  if (i % 3 == 0) {
    sum = sum + i
  }
}
console.log(sum)
```

- 求学生成绩案例

```javascript
// 要求用户输入班级人数，之后依次输入每个学生的成绩，最后打印出该班级总的成绩以及平均成绩。
// 弹出输入框输入总的班级人数 ( num )
// 依次输入学生的成绩（保存起来 score），此时我们需要用到 for 循环，弹出的次数跟班级总人数有关系   条件表达式  i <= num
// 进行业务处理:  计算成绩。 先求总成绩（sum），之后求平均成绩（average）
// 弹出结果
var num = prompt('请输入班级总的人数')
var sum = 0
var avg = 0
for (var i = 1; i <= num; i++) {
  var score = prompt('第' + i + '个学生成绩是:')
  //字符串型转换为数字型
  sum = sum + parseFloat(score)
}
avg = sum / num
console.log('该班级总成绩是' + sum)
console.log('该班级平均成绩是' + avg)
```

### 打印一行 5 个星星

```javascript
//一行打印5个星星
var str = ''
for (var i = 1; i <= 5; i++) {
  str = str + '★'
}
console.log(str)
//输入星星的数量
var num = prompt('请输入星星的个数')
var str = ''
for (var i = 0; i <= num; i++) {
  str = str + '★'
}
console.log(str)
```

## 双重 for 循环

```javascript
//双重for循环
// for (外层的初始化变量; 外层的表达式; 外层的操作表达式) {
//     for (里层的初始化变量; 里层的表达式; 里层的操作表达式) {
//         //执行语句
//     }
// }
//里面的循环看成外层循环的语句
//外层循环 循环一次 里面的循环执行全部
//代码验证

for (var i = 1; i <= 3; i++) {
  console.log('这是外层循环第' + i + '次')
  for (var j = 1; j <= 3; j++) {
    console.log('这是里层的循环第' + j + '次')
  }
}
```

- 打印 5 行 5 列 星星

```javascript
var str = ''
for (var i = 1; i <= 5; i++) {
  //外层循环负责打印5行
  for (var j = 1; j <= 5; j++) {
    //里层循环负责一行打印5个星星
    str = str + '★'
  }
  //如果一行打印完毕5个星星就要另起一行 加\n
  str = str + '\n'
}
console.log(str)
```

- 打印 n 行 n 列 星星

```javascript
var num1 = prompt('请输入您输入打印几行星星')
var num2 = prompt('请您输入打印几列星星')
var str = ''
for (var i = 1; i <= num1; i++) {
  for (var j = 1; j <= num2; j++) {
    str = str + '★'
  }
  str = str + '\n'
}
console.log(str)
```

- 打印倒三角

```javascript
var str = ''
for (var i = 1; i <= 10; i++) {
  //外层循环控制行数
  for (var j = i; j <= 10; j++) {
    //里层循环 打印个数不一样 j=i
    str = str + '★'
  }
  str = str + '\n'
}
console.log(str)
```

- 打印九九乘法表

```javascript
//         一共有9行，但是每行的个数不一样，因此需要用到双重 for 循环
// 外层的 for 循环控制行数 i ，循环9次 ，可以打印 9 行
// 内层的 for 循环控制每行公式  j
// 核心算法：每一行 公式的个数正好和行数一致， j <= i;
// 每行打印完毕，都需要重新换一行
// 把公式用 i 和 j 替换

var str = ''
for (var i = 1; i <= 9; i++) {
  //外层循环控制行数
  for (var j = 1; j <= i; j++) {
    //里层循环控制每一行的个数 j<=i
    // 1 x 2 =2;
    //str = str + '★';
    str += i + 'x' + j + '=' + i * j + '\t' //先列出公式 再对照公式 用相应的变量替换并拼接
  }
  str += '\n'
}
console.log(str)
```

## while 循环

- 语法结构

```javascript
//语法结构 当...时候

// while (条件表达式) {
//     //循环体
// }
//执行思路 当条件表达式结果为true 则执行循环体 否则 退出循环
var num = 1
while (num <= 100) {
  num++
  console.log('你好')
}
//里面应有计数器 初始化变量
//里面应该有操作表达式 完成计数器的更新 防止死循环
```

- 案例

```javascript
// 打印人的一生，从1岁到100岁
var i = 1
while (i <= 100) {
  console.log('今年你' + i + '岁')
  i++
}

// 计算 1 ~ 100 之间所有整数的和
var j = 1
var sum = 0
while (j <= 100) {
  sum = sum + j
  j++
}
console.log(sum)

//弹出一个提示框， 你爱我吗？  如果输入我爱你，就提示结束，否则，一直询问。
var message = prompt('你爱我吗？')
while (message !== '我爱你') {
  message = prompt('你爱我吗')
}
alert('我也爱你啊')
```

## do while 循环

- 语法结构

```javascript
//语法结构
// do {
//     //循环体
// } while (条件表达式)

//执行思路 先执行一次循环体 在判断条件 如果条件表达式结果为真 继续执行循环体 否则退出循环
//代码验证
var i = 1
do {
  console.log('你好吗')
  i++
} while (i <= 100) //do while至少执行一次循环体
```

- 案例

```javascript
// 打印人的一生，从1岁到100岁
var i = 1
do {
  console.log('今年你已经' + i + '岁')
  i++
} while (i <= 100)

// 计算 1 ~ 100 之间所有整数的和
var j = 1
var sum = 0
do {
  sum = sum + j
  j++
} while (j <= 100)
console.log(sum)
//弹出一个提示框， 你爱我吗？  如果输入我爱你，就提示结束，否则，一直询问。
do {
  message = prompt('你爱我吗')
} while (message !== '我爱你')
alert('我也爱你')
```

## **continue**

```javascript
//continue
for (var i = 1; i <= 5; i++) {
  if (i == 3) {
    continue //只要遇见 continue 就退出本次循环 直接跳到i++
  }
  console.log('我正在吃第' + i + '个包子')
}
```

- 案例

```javascript
//求1~100之间 除了能被7整除之外的整数和
var sum = 0
for (var i = 1; i <= 100; i++) {
  if (i % 7 == 0) {
    continue
  }
  sum = sum + i
}
console.log(sum)
```

## **break**

```javascript
//break
for (var i = 1; i <= 5; i++) {
  if (i == 3) {
    break //直接退出循环
  }
  console.log('我正在吃第' + i + '个包子')
}
```

## 循环案例--简易 ATM

```javascript
// 里面现存有  100 块钱。
// 如果存钱，就用输入钱数加上先存的钱数, 之后弹出显示余额提示框
// 如果取钱，就减去取的钱数，之后弹出显示余额提示框
// 如果显示余额，就输出余额
// 如果退出，弹出退出信息提示框
//初始化金额
var money = 100 //设置初始⾦额
while (true) {
  var action = prompt(
    '请输⼊以下序列号进⾏操作:\n 1.存款 \n 2.取款 \n 3.查看余额 \n 4.取卡'
  )
  switch (
    parseInt(action) //字符型转换为数字型
  ) {
    case 1:
      var ck = prompt('请输⼊要存⼊的⾦额')
      if (ck == '') {
        alert('输⼊的⾦额有误')
      } else {
        money += parseInt(ck)
        alert('您现在当前的余额为' + money + '元')
      }
      break
    case 2:
      var qk = prompt('请输⼊要取出的⾦额')
      if (qk == '') {
        alert('您输⼊的⾦额有误')
      } else if (money >= qk) {
        money -= qk
        alert('您已成功取出' + qk + '元' + '所剩余额为' + money + '元')
      } else {
        alert('您的余额不⾜')
      }
      break
    case 3:
      alert('您好您当前的余额为' + money + '元')
      break
    case 4:
      alert('您的银⾏卡已取出')
      break
    default:
      alert('请输⼊正确的指令')
  }
  if (action == 4) {
    //⽤户执⾏完取卡,⽤来终⽌循环的
    break
  }
}
```

## 数组

### 创建数组

- **利用数组字面量创建数组[最常用]**

```javascript
var arr = []
```

- 利用 new 创建数组

```javascript
var arr = new Array()
```

### 获取数组元素

```javascript
var arr1 = [1, 2, 3, 'pink', true]
// 6. 获取数组元素  格式 数组名[索引号]  索引号从 0开始
console.log(arr1[3]) //pink
```

### 遍历数组

```javascript
// 遍历数组：就是把数组的元素从头到尾访问一次
var arr = ['red', 2, 3]
for (var i = 0; i < 3; i++) {
  console.log(arr[i])
}
// 1. 因为我们的数组索引号从0开始 ，所以 i 必须从 0开始  i < 3
// 2. 输出的时候 arr[i]  i 计数器当索引号来用
```

### 数组长度

```javascript
// 数组长度 数组名.length
var arr = ['关羽', '张飞', '马超', '赵云', '黄忠', '刘备', '姜维', 'pink']
for (var i = 0; i < 7; i++) {
  console.log(arr[i])
}
console.log(arr.length)
for (var i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
// 1. 数组的长度是元素个数  不要跟索引号混淆
// 2. arr.length 动态监测数组元素的个数
```

- 案例

```javascript
// 1. 求数组 [2,6,1,7, 4] 里面所有元素的和以及平均值。
// (1)声明一个求和变量 sum。
// (2)遍历这个数组，把里面每个数组元素加到 sum 里面。
// (3)用求和变量 sum 除以数组的长度就可以得到数组的平均值。
var arr = [2, 6, 1, 7, 4]
var sum = 0
var avg = 0
for (var i = 0; i < arr.length; i++) {
  sum += arr[i] // 我们加的是数组元素 arr[i] 不是计数器 i
}
avg = sum / arr.length
console.log(sum, avg) // 想要输出多个变量，用逗号分隔即可
```

### 数组最大值

```javascript
// 求数组[2,6,1,77,52,25,7]中的最大值
// 声明一个保存最大元素的变量 max。
// 默认最大值可以取数组中的第一个元素。
// 遍历这个数组，把里面每个数组元素和 max 相比较。
// 如果这个数组元素大于max 就把这个数组元素存到 max 里面，否则继续下一轮比较。
// 最后输出这个 max
var arr = [2, 6, 1, 77, 52, 25, 7]
var max = arr[0]
for (var i = 1; i < arr.length; i++) {
  if (arr[i] > max) {
    max = arr[i]
  }
}
console.log('该数组最大值是' + max)
```

### 数组转换为字符串

```javascript
// 将数组 ['red', 'green', 'blue', 'pink'] 转换为字符串，并且用 | 或其他符号分割
// 1.需要一个新变量用于存放转换完的字符串 str。
// 2.遍历原来的数组，分别把里面数据取出来，加到字符串里面。
// 3.同时在后面多加一个分隔符
var arr = ['red', 'green', 'blue', 'pink']
var str = ''
var sep = '!'
for (var i = 0; i < arr.length; i++) {
  str += arr[i] + sep
}
console.log(str)
```

### 新增数组元素

- 新增数组元素 修改 length 长度

```javascript
var arr = ['red', 'green', 'blue']
console.log(arr.length)
arr.length = 5
console.log(arr) //['red', 'green', 'blue', empty × 2]
console.log(arr[3]) //undefined
console.log(arr[4]) //undefined
```

- 新增数组元素 修改索引号 追加数组元素

> 不要直接给数组名 赋值 否则会覆盖以前的数据

```javascript
var arr1 = ['red', 'green', 'blue']
arr1[3] = 'pink'
console.log(arr1)
arr1[4] = 'hotpink'
console.log(arr1)
arr1[0] = 'yellow' //替换原来的数组元素
console.log(arr1)
arr1 = 'xt'
console.log(arr1) //不要直接给数组名 赋值 否则会覆盖以前的数据
```

### 数组存放 1~10 个值

```javascript
// 新建一个数组，里面存放10个整数（ 1~10）
// 核心原理：使用循环来追加数组。
// 1、声明一个空数组 arr。
// 2、循环中的计数器 i  可以作为数组元素存入。
// 3、由于数组的索引号是从0开始的， 因此计数器从 0 开始更合适，存入的数组元素要+1。
var arr = []
for (var i = 0; i < 10; i++) {
  // arr =i;不要直接给数组名赋值；
  arr[i] = i + 1
}
console.log(arr)
```

### 筛选数组

- 方法 1

```javascript
// 将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数组。
// 1、声明一个新的数组用于存放新数据newArr。
// 2、遍历原来的旧数组， 找出大于等于 10 的元素。
// 3、依次追加给新数组 newArr。
// 方法1
var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]
var newArr = []
var j = 0
for (var i = 0; i < arr.length; i++) {
  if (arr[i] >= 10) {
    //新数组索引号应该是从0开始  依次递增
    newArr[j] = arr[i]
    j++
  }
}
console.log(newArr)
```

- 方法 2

```javascript
var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]
var newArr = []
// 刚开始newArr.length 就是0
for (var i = 0; i < arr.length; i++) {
  if (arr[i] >= 10) {
    //新数组索引号应该是从0开始  依次递增
    newArr[newArr.length] = arr[i]
  }
}
console.log(newArr)
```

### 案例

- 数组去重(删除指定数组元素)

```javascript
// 将数组[2, 0, 6, 1, 77, 0, 52, 0, 25, 7]中的 0 去掉后，形成一个不包含 0 的新数组。
// 1、需要一个新数组用于存放筛选之后的数据。
// 2、遍历原来的数组， 把不是 0 的数据添加到新数组里面(此时要注意采用数组名 + 索引的格式接收数据)。
// 3、新数组里面的个数， 用 length 不断累加。
var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]
var newArr = []
for (var i = 0; i < arr.length; i++) {
  if (arr[i] != 0) {
    newArr[newArr.length] = arr[i]
  }
}
console.log(newArr) //[2, 6, 1, 77, 52, 25, 7]
```

- 翻转数组

```javascript
// 将数组 ['red', 'green', 'blue', 'pink', 'purple'] 的内容反过来存放
// 1、声明一个新数组 newArr
// 2、把旧数组索引号第4个取过来（arr.length - 1)，给新数组索引号第0个元素 (newArr.length)
// 3、我们采取 递减的方式  i--
var arr = ['red', 'green', 'blue', 'pink', 'purple']
var newArr = []
for (var i = arr.length - 1; i >= 0; i--) {
  newArr[newArr.length] = arr[i]
}
console.log(newArr) //['purple', 'pink', 'blue', 'green', 'red']
```

### 冒泡排序

- 一种算法 把一系列数据按照一定的顺序排列

```javascript
// 冒泡排序
// var arr = [5, 4, 3, 2, 1];
var arr = [4, 1, 2, 3, 5]
for (var i = 0; i < arr.length - 1; i++) {
  //外层循环管趟数
  for (var j = 0; j <= arr.length - i - 1; j++) {
    //内层循环管每一趟的交换次数
    //内部交换两个变量的值 前一个元素和后面一个数组元素进行比较
    if (arr[j] > arr[j + 1]) {
      var temp = arr[j]
      arr[j] = arr[j + 1]
      arr[j + 1] = temp
    }
  }
}
console.log(arr)
```

## 函数

### 函数使用

> 声明函数和调用函数

```javascript
// 函数使用分为两步： 声明函数 和 调用函数
// 1. 声明函数
// function 函数名() {
//     // 函数体
// }
function sayHi() {
  console.log('hi~~')
}
// (1) function 声明函数的关键字 全部小写
// (2) 函数是做某件事情，函数名一般是动词 sayHi
// (3) 函数不调用自己不执行
// 2. 调用函数
// 函数名();
sayHi()
// 调用函数的时候千万不要忘记加小括号
```

### 利用函数封装求 1~100 的和

```javascript
// 利用函数计算1-100之间的累加和
// 1. 声明函数
function getSum(num1, num2) {
  var sum = 0
  for (var i = num1; i <= num2; i++) {
    sum += i
  }
  console.log(sum)
}
//2.调用函数
getSum(1, 100)
```

### 带参数的函数

- 函数实现重复相同的代码

```javascript
function cook() {
  console.log('酸辣土豆丝')
}
cook()
cook()
```

- 利用函数的参数实现函数重复不同的代码

  - 格式

  ```javascript
  function 函数名(形参1,形参2...) { // 在声明函数的小括号里面是 形参 （形式上的参数）

  }
  函数名(实参1,实参2...); // 在函数调用的小括号里面是实参（实际的参数）
  ```

  - 形参和实参的执行过程
    - 形参 声明函数
    - 实参 调用函数

  ```javascript
  function cook(aru) {
    // 形参是接受实参的  aru = '酸辣土豆丝' 形参类似于一个变量
    console.log(aru)
  }
  cook('酸辣土豆丝')
  ```

### 利用函数求任意两个数的和

```javascript
// 1. 利用函数求任意两个数的和
function getSum(num1, num2) {
  console.log(num1 + num2)
}
getSum(1, 3)
getSum(3, 8)
// 2. 利用函数求任意两个数之间的和
function getSum(num1, num2) {
  var sum = 0
  for (i = num1; i <= num2; i++) {
    sum += i
  }
  console.log(sum)
}
getSum(1, 100)
getSum(1, 10)

// 3. 注意点
// (1) 多个参数之间用逗号隔开
// (2) 形参可以看做是不用声明的变量
```

### 函数形参实参个数匹配

```javascript
// 函数形参实参个数匹配
function getSum(num1, num2) {
  console.log(num1 + num2)
}
// 1. 如果实参的个数和形参的个数一致 则正常输出结果
getSum(1, 2)
// 2. 如果实参的个数多于形参的个数  会取到形参的个数
getSum(1, 2, 3)
// 3. 如果实参的个数小于形参的个数  多于的形参定义为undefined  最终的结果就是 NaN
// 形参可以看做是不用声明的变量  num2 是一个变量但是没有接受值  结果就是undefined
getSum(1) // NaN
// 建议 我们尽量让实参的个数和形参相匹配
```

### 函数的返回值

#### return 语句

- 格式

```javascript
// 2. 函数的返回值格式
function 函数名() {
  return 需要返回的结果
}
函数名()
// (1) 我们函数只是实现某种功能，最终的结果需要返回给函数的调用者函数名() 通过return 实现的
// (2) 只要函数遇到return 就把后面的结果 返回给函数的调用者  函数名() = return后面的结果
```

- 代码验证

```javascript
function getResult() {
  return 666
}
getResult() // getResult()   = 666
console.log(getResult())
```

#### 求两个数的最大值（函数版)

```javascript
function getMax(num1, num2) {
  // if (num1 > num2) {
  //     return num1;
  // } else {
  //     return num2;
  // }
  return num1 > num2 ? num1 : num2
}
console.log(getMax(1, 3))
console.log(getMax(11, 3))
```

#### 求数组中的最大值(函数版)

```javascript
// 利用函数求数组 [5,2,99,101,67,77] 中的最大数值。
function getArrMax(arr) {
  //arr 接受一个数组
  var max = arr[0]
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i]
    }
  }
  return max
}
var re = getArrMax([5, 2, 99, 101, 67, 77]) // 实参是一个数组送过去
console.log(re) // 在我们实际开发里面，我们经常用一个变量来接受 函数的返回结果 使用更简单
```

#### 注意事项

- **return 终止函数作用**

```javascript
function getSum(num1, num2) {
  return num1 + num2 // return 后面的代码不会被执行
  alert('我是不会被执行的哦！')
}
console.log(getSum(1, 2))
```

- return 只能返回一个值

```javascript
function fn(num1, num2) {
  return num1, num2 // 返回的结果是最后一个值
}
console.log(fn(1, 2))
```

- return 返回数组

```javascript
function getResult(num1, num2) {
  return [num1 + num2, num1 - num2, num1 * num2, num1 / num2]
}
var re = getResult(1, 2) // 返回的是一个数组
console.log(re)
```

- 我们的函数如果有 return 则返回的是 return 后面的值，如果函数么有 return 则返回 undefined

```javascript
function fun1() {
  return 666
}
console.log(fun1()) // 返回 666
function fun2() {}
console.log(fun2()) // 函数返回的结果是 undefined
```

### 函数作业

- 写一个函数，用户输入任意两个数字的任意算术运算（简单的计算器小功能），并能弹出运算后的结果。

```javascript
function compute() {
  var num1 = prompt('请输入数字1：')
  var sign = prompt('请输入运算符：')
  var num2 = prompt('请输入数字2：')
  if (sign == '+') {
    return parseFloat(num1) + parseFloat(num2)
  } else if (sign == '-') {
    return parseFloat(num1) - parseFloat(num2)
  } else if (sign == '*') {
    return parseFloat(num1) * parseFloat(num2)
  } else if (sign == '/') {
    return parseFloat(num1) / parseFloat(num2)
  }
}
var result = compute()
alert('运算结果是' + result)
```

- 写一个函数，用户输入任意两个数字的最大值，并能出弹运算后的结果。

```javascript
var number1 = parseFloat(prompt('请输入第一个数字:'))
var number2 = parseFloat(prompt('请输入第二个数字:'))
function getMax(number1, number2) {
  // if (number1 > number2) {
  //     return number1;
  // } else
  //     return number2;
  return number1 > number2 ? number1 : number2
}
var str = getMax(number1, number2)
alert('最大值是' + str)
```

- 写一个函数，用户输入任意三个不同数字的最大值，并能弹出运算后的结果。

```javascript
var num1 = parseInt(prompt('输入第一个数字')) //parseInt（）强制转换字符串类型
var num2 = parseInt(prompt('输入第二个数字'))
var num3 = parseInt(prompt('输入第三个数字'))
var max = 0
var str = [num1, num2, num3]
function getmax(num1, num2, num3) {
  for (var i = 0; i < str.length; i++) {
    if (max < str[i]) {
      max = str[i]
    }
  }
  return max
}
var str2 = getmax(num1, num2, num3)
alert('最大值为：' + str2)
```

- 写一个函数，用户输入一个数判断是否是素数，并返弹出回值(又叫质数，只能被 1 和自身整数的数)

```javascript
function isPrime(num) {
  // 因为 计数器 i 要与 质数num 作比较，而质数是大于 1 的，所以 i 初始值设为 2
  for (var i = 2; i < num; i++) {
    if (num % i == 0) {
      return num + '不是质数'
    }
  }
  return num + '是质数'
}
alert(isPrime(1))
```

### arguments 使用

```javascript
// arguments 的使用  只有函数才有 arguments对象  而且是每个函数都内置好了这个arguments
function fn() {
  // console.log(arguments); // 里面存储了所有传递过来的实参  arguments = [1,2,3]
  // console.log(arguments.length);
  // console.log(arguments[2]);
  // 我们可以按照数组的方式遍历arguments
  for (var i = 0; i < arguments.length; i++) {
    console.log(arguments[i])
  }
}
fn(1, 2, 3)
fn(1, 2, 3, 4, 5)
// 伪数组 并不是真正意义上的数组
// 1. 具有数组的 length 属性
// 2. 按照索引的方式进行存储的
// 3. 它没有真正数组的一些方法 pop()  push() 等等
```

#### 利用函数求任意个数的最大值

```javascript
// 利用函数求任意个数的最大值
function getMax() {
  //arguments = [1,2,3]
  var max = arguments[0]
  for (var i = 1; i < arguments.length; i++) {
    if (arguments[i] > max) {
      max = arguments[i]
    }
  }
  return max
}
console.log(getMax(1, 2, 3))
console.log(getMax(1, 2, 3, 4, 5))
console.log(getMax(1, 2, 3, 34, 55, 100))
```

### 利用函数翻转数组

```javascript
function reverse(arr) {
  var newArr = []
  for (var i = arr.length - 1; i >= 0; i--) {
    newArr[newArr.length] = arr[i]
  }
  return newArr
}
var arr1 = reverse([1, 3, 4, 6, 9])
console.log(arr1)
var arr2 = reverse(['red', 'blue', 'orange'])
console.log(arr2)
```

### 利用函数冒泡排序

```javascript
function sort(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    //趟数
    for (var j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        var temp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = temp
      }
    }
  }
  return arr
}
var arr1 = sort([1, 4, 2, 9])
console.log(arr1)
var arr2 = sort([11, 7, 22, 999])
console.log(arr2)
```

### 利用函数判断闰年

```javascript
function isRunYear(year) {
  //如果是闰年 我们返回true 否则 返回 false
  var flag = false
  if (year % 4 == 0 && year % 100 != 0 && year % 400 == 0) {
    flag = true
  }
  return flag
}
console.log(isRunYear(2000))
```

### 函数是可以相互调用的

```javascript
// 函数是可以相互调用的
function fn1() {
  console.log(11)
  fn2() // 在fn1 函数里面调用了 fn2 函数
}
fn1()

function fn2() {
  console.log(22)
}
```

#### 案例

```javascript
//用户输入年份 输出当前年份2月份的天数
function backday() {
  var year = prompt('请您输入年份')
  if (isRunYear(year)) {
    //调用函数 加小括号
    alert('当前年份是闰年，2月份有29天')
  } else {
    alert('当前年份是平年，2月份有28天')
  }
}
backday()

function isRunYear(year) {
  //如果是闰年 我们返回true 否则 返回 false
  var flag = false
  if (year % 4 == 0 && year % 100 != 0 && year % 400 == 0) {
    flag = true
  }
  return flag
}
```

### 函数的两种声明方式

- 利用函数关键字自定义函数(命名函数)

```javascript
function fn() {}
fn()
```

- 函数表达式(匿名函数)

```javascript
// var 变量名 = function() {};
var fun = function (aru) {
  console.log('我是函数表达式')
  console.log(aru)
}
fun('pink老师')
// (1) fun是变量名 不是函数名
// (2) 函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值 而 函数表达式里面存的是函数
// (3) 函数表达式也可以进行传递参数
```

## JavaScript 作用域

> JavaScript 作用域 ： 就是代码名字（变量）在某个范围内起作用和效果 目的是为了提高程序的可靠性更重要的是减少命名冲突

### 全局作用域

```javascript
//js的作用域（es6）之前 ： 全局作用域   局部作用域
// 全局作用域： 整个script标签 或者是一个单独的js文件
var num = 10
var num = 30
console.log(num)
```

### 局部作用域

```javascript
// 局部作用域（函数作用域） 在函数内部就是局部作用域 这个代码的名字只在函数内部起效果和作用
function fn() {
  // 局部作用域
  var num = 20
  console.log(num)
}
fn()
```

### 变量作用域

- 全局变量
  - 在代码任何位置都可以直接使用
  - 在全局作用域下，var 声明的变量是全局变量
  - **特殊情况，在函数内不使用 var 声明的变量也是全局变量【不建议使用】**

```javascript
// 1. 全局变量： 在全局作用域下的变量 在全局下都可以使用
var num = 10 // num就是一个全局变量
console.log(num)

function fn() {
  console.log(num)
}
fn()
```

- 局部变量
  - 只能在函数内部使用
  - 在函数内部用 var 声明的变量
  - 函数形参也是局部变量

> 注意 如果在函数内部 没有声明直接赋值的变量也属于全局变量
>
> 注意： 函数的形参也可以看做是局部变量

```javascript
// 2. 局部变量   在局部作用域下的变量   后者在函数内部的变量就是 局部变量
function fun(aru) {
  var num1 = 10 // num1就是局部变量 只能在函数内部使用
  num2 = 20
}
fun()
// console.log(num1);//undefined
// console.log(num2);//20
```

- 全局变量与局部变量 区别

  - 从执行效率来看全局变量和局部变量

  1.  **全局变量**只有浏览器关闭的时候才会销毁，**比较占内存资源**
  2.  **局部变量** 当我们程序执行完毕就会销毁， **比较节约内存资源**

### 作用域链

```javascript
// 作用域链  ： 内部函数访问外部函数的变量，采取的是链式查找的方式来决定取那个值 这种结构我们称为作用域链   就近原则
var num = 10
function fn() {
  // 外部函数
  var num = 20
  function fun() {
    // 内部函数
    console.log(num)
  }
  fun()
}
fn()
```

#### 案例

```javascript
var a = 1
function fn1() {
  var a = 2
  var b = '22'
  fn2()

  function fn2() {
    var a = 3
    fn3()

    function fn3() {
      var a = 4
      console.log(a) //a的值 ?  4
      console.log(b) //b的值 ?  22
    }
  }
}
fn1()
```

### 预解析

- 我们 js 引擎运行 js 分为两步： **预解析 代码执行**

  - 预解析 js 引擎会把 js 里面所有的 var 还有 function 提升到当前作用域的最前面
  - 代码执行 按照代码书写的顺序从上往下执行

- 预解析分为 变量预解析（变量提升） 和 函数预解析（函数提升）
  - 变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作
  - 函数提升 就是把所有的函数声明提升到当前作用域的最前面 不调用函数

```javascript
console.log(num) // undefined  坑 1
var num = 10
// 相当于执行了以下代码
// var num;
// console.log(num);
// num = 10;
```

```javascript
fun() // 报错  坑2
var fun = function () {
  console.log(22)
}
// 函数表达式 调用必须写在函数表达式的下面
// 相当于执行了以下代码
// var fun;
// fun();
// fun = function() {
//         console.log(22);

//     }
```

## JavaScript 对象

> 一组无序的相关属性和方法的集合【字符串，数值，数组，函数】
>
> 属性：特征，名词
>
> 方法：行为，动词
>
> 对象表达结构更清晰，更强大

### 创建对象

#### **利用字面量创建对象**

- 里面的属性或者方法我们采取**键值对**的形式 键 属性名 ： 值 属性值
- 多个属性或者方法中间用**逗号隔开**的
- **方法冒号后面跟的是一个匿名函数**

```javascript
//var obj = {};  // 创建了一个空的对象
var obj = {
  uname: '张三疯',
  age: 18,
  sex: '男',
  sayHi: function () {
    console.log('hi~')
  },
}
```

- 使用对象

```javascript
//(1). 调用对象的属性 我们采取 对象名.属性名 . 我们理解为 的
console.log(obj.uname)
// (2). 调用属性还有一种方法 对象名['属性名']
console.log(obj['age'])
// (3) 调用对象的方法 sayHi   对象名.方法名() 千万别忘记添加小括号
obj.sayHi()
```

#### **利用 new Object 创建对象**

- 我们是利用 **等号 = 赋值**的方法 添加对象的属性和方法
- 每个属性和方法之间用 **分号结束**

```javascript
var obj = new Object() // 创建了一个空的对象
obj.uname = '张三疯'
obj.age = 18
obj.sex = '男'
obj.sayHi = function () {
  console.log('hi~')
}
```

- 使用对象

```javascript
console.log(obj.uname)
console.log(obj['sex'])
obj.sayHi()
```

#### 利用构造函数创建对象

> 因为我们一次创建一个对象，里面很多的属性和方法是大量相同的 我们只能复制
>
> 因此我们可以利用函数的方法 重复这些相同的代码 我们就把这个函数称为 构造函数

- 又因为这个函数不一样，**里面封装的不是普通代码，而是 对象**

- **构造函数 就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面**

- 语法格式
  - 构造函数名字首字母要大写
  - 我们构造函数不需要 return 就可以返回结果
  - 我们**调用构造函数 必须使用 new**
  - 我们只要 new Star() 调用函数就创建一个对象 ldh {}
  - 我们的属性和方法前面必须添加 this

```javascript
function 构造函数名() {
  this.属性 = 值
  this.方法 = function () {}
}
new 构造函数名()
```

- 调用构造函数

```javascript
new 构造函数名()
```

- 案例

```javascript
function Star(uname, age, sex) {
  this.name = uname
  this.age = age
  this.sex = sex
  this.sing = function (sang) {
    console.log(sang)
  }
}
var ldh = new Star('刘德华', 18, '男') // 调用函数返回的是一个对象
// console.log(typeof ldh);//object
console.log(ldh.name)
console.log(ldh['sex'])
ldh.sing('冰雨')
var zxy = new Star('张学友', 19, '男')
console.log(zxy.name)
console.log(zxy.age)
zxy.sing('李香兰')
```

### 变量属性函数方法区别

```javascript
// 1.变量和属性的相同点 他们都是用来存储数据的
var num = 10
var obj = {
  age: 18,
  fn: function () {},
}

function fn() {}
console.log(obj.age)
// console.log(age);

// 变量 单独声明并赋值  使用的时候直接写变量名 单独存在
// 属性 在对象里面的不需要声明的 使用的时候必须是 对象.属性
// 2. 函数和方法的相同点 都是实现某种功能  做某件事
// 函数是单独声明 并且调用的 函数名() 单独存在的
// 方法 在对象里面 调用的时候 对象.方法()
```

### 构造函数和对象区别

```javascript
// 1. 构造函数  明星 泛指的某一大类  它类似于 java 语言里面的  类(class)
function Star(uname, age, sex) {
  this.name = uname
  this.age = age
  this.sex = sex
  this.sing = function (sang) {
    console.log(sang)
  }
}
// 2. 对象 特指 是一个具体的事物 刘德华 ==  {name: "刘德华", age: 18, sex: "男", sing: ƒ}
var ldh = new Star('刘德华', 18, '男') // 调用函数返回的是一个对象
console.log(ldh)
// 3. 我们利用构造函数创建对象的过程我们也称为对象的实例化
```

### new 关键字

- 执行过程
  - new 构造函数可以在内存中创建了一个空的对象
  - this 就会指向刚才创建的空对象
  - 执行构造函数里面的代码 给这个空对象添加属性和方法
  - 返回这个对象

### 遍历对象

- for in 遍历我们的对象

```javascript
for (变量 in 对象) {
}
```

```javascript
var obj = {
  name: 'pink老师',
  age: 18,
  sex: '男',
  fn: function () {},
}
// for in 遍历我们的对象
for (var k in obj) {
  console.log(k) // k 变量 输出  得到的是 属性名
  console.log(obj[k]) // obj[k] 得到是 属性值
}
// 我们使用 for in 里面的变量 我们喜欢写 k  或者  key
```

### 对象作业

- 创建一个电脑对象，该对象要有颜色、重量、品牌、型号，可以看电影、听音乐、打游戏和敲代码。

```javascript
function Computer(color, weight, brand, type) {
  this.color = color
  this.weight = weight
  this.brand = brand
  this.type = type
  this.see = function (movie) {
    console.log(movie)
  }
  this.listen = function (song) {
    console.log(song)
  }
  this.play = function (game) {
    console.log(game)
  }
  this.study = function (code) {
    console.log(code)
  }
}
var Dell = new Computer('red', '20kg', 'Dell', '笔记本')
console.log(typeof Dell)
Dell.see('一起看爱死机')
Dell.listen('一起听林俊杰的歌')
```

- 创建一个按钮对象，该对象中需要包含宽，高，背景颜色和点击行为。

```javascript
function Button(weight, height, bg_color) {
  this.weight = weight
  this.height = height
  this.color = bg_color

  this.click = function (click) {
    console.log('写的代码点击就成功')
  }
}
var button1 = new Button('20', '20', 'black')
console.log(button1['color'])
console.log(button1.height)
button1.click()
```

- 创建一个车的对象，该对象要有重量、颜色、牌子，可以载人、拉货和耕田。

```javascript
function Car(weight, color, brand) {
  this.weight = weight
  this.color = color
  this.brand = brand
  this.carry = function (human) {
    console.log('可以载人！')
  }
  this.pull = function (goods) {
    console.log('可以拉货！')
  }
  this.plow = function (fields) {
    console.log('可以耕田！')
  }
}
var Tesla = new Car('200kg', '白色', 'Tesla')
console.log(Tesla['color'])
Tesla.carry()
```

## JavaScript 内置对象

### 内置对象

- JS 语言自带对象【常用的方法和属性】

### Math 对象

#### Math 最大值

> Math 数学对象 不是一个构造函数 ，所以我们不需要 new 来调用 而是直接使用里面的属性和方法即可

```javascript
console.log(Math.PI) // 一个属性 圆周率
console.log(Math.max(1, 99, 3)) // 99
console.log(Math.max(-1, -10)) // -1
console.log(Math.max(1, 99, 'pink老师')) // NaN
console.log(Math.max()) // -Infinity
```

- 封装自己的数学对象

```javascript
// 利用对象封装自己的数学对象  里面有 PI 最大值和最小值
var myMath = {
  PI: 3.141592653,
  max: function () {
    var max = arguments[0]
    for (var i = 1; i < arguments.length; i++) {
      if (arguments[i] > max) {
        max = arguments[i]
      }
    }
    return max
  },
  min: function () {
    var min = arguments[0]
    for (var i = 1; i < arguments.length; i++) {
      if (arguments[i] < min) {
        min = arguments[i]
      }
    }
    return min
  },
}
console.log(myMath.PI)
console.log(myMath.max(1, 5, 9))
console.log(myMath.min(1, 5, 9))
```

#### Math 绝对值

```javascript
console.log(Math.abs(1)) // 1
console.log(Math.abs(-1)) // 1
console.log(Math.abs('-1')) // 隐式转换 会把字符串型 -1 转换为数字型
console.log(Math.abs('pink')) // NaN
```

#### 三个取整方法

##### **Math.floor()**

> 地板 向下取整 往最小了取值

```javascript
console.log(Math.floor(1.1)) // 1
console.log(Math.floor(1.9)) // 1
```

##### **Math.ceil()**

> 天花板 向上取整 往最大了取值

```javascript
console.log(Math.ceil(1.1)) // 2
console.log(Math.ceil(1.9)) // 2
```

##### **Math.round()**

> 四舍五入 其他数字都是四舍五入，但是 .5 特殊 它往大了取

```javascript
console.log(Math.round(1.1)) // 1
console.log(Math.round(1.5)) // 2
console.log(Math.round(1.9)) // 2
console.log(Math.round(-1.1)) // -1
console.log(Math.round(-1.5)) // 这个结果是 -1
```

#### Math 对象随机数方法

> random() 返回一个随机的小数 0 =< x < 1
>
> 这个方法里面不跟参数

```javascript
console.log(Math.random())
```

- 我们想要得到两个数之间的随机整数 并且 包含这 2 个整数

```javascript
function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}
console.log(getRandom(1, 10))
```

```javascript
//随机点名
var arr = ['张三', '张三丰', '张三疯子', '李四', '李思思', 'pink老师']
// console.log(arr[0]);
console.log(arr[getRandom(0, arr.length - 1)])
```

#### 猜数字游戏

```javascript
// 1.随机生成一个1~10 的整数  我们需要用到 Math.random() 方法。
// 2.需要一直猜到正确为止，所以需要一直循环。
// 3.while 循环更简单
// 4.核心算法：使用 if  else if 多分支语句来判断大于、小于、等于。
function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}
var random = getRandom(1, 10)
while (true) {
  //死循环
  var num = prompt('你来猜？输入1-10之间的数字')
  if (num > random) {
    alert('你猜大了')
  } else if (num < random) {
    alert('你猜小了')
  } else {
    alert('你好帅，猜对了')
    break
  }
}
```

- 要求用户猜 1~50 之间的一个数字 但是只有 10 次猜的机会

```javascript
function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}
var random = getRandom(1, 50)
for (var i = 9; i >= 0; i--) {
  var num = prompt('请你输入要猜的数字：')
  if (num > random) {
    alert('你猜大了' + '\n你还剩' + i + '次机会')
  } else if (num < random) {
    alert('你猜小了' + '\n你还剩' + i + '次机会')
  } else {
    alert('恭喜你猜对啦!' + '\n答案就是' + random)
    break
  }
}
```

### 日期对象

#### 使用 Date

> 使用 Date 如果没有参数 返回当前系统的当前时间

```javascript
var date = new Date()
console.log(date)
```

> 参数常用的写法 数字型 2022, 10, 01 或者是 字符串型 '2022-10-1 8:8:8'

```javascript
var date1 = new Date(2022, 10, 1)
console.log(date1) // 返回的是 11月 不是 10月
var date2 = new Date('2022-10-1 8:8:8')
console.log(date2)
```

#### 格式化日期年月日

```javascript
var date = new Date()
console.log(date.getFullYear()) // 返回当前日期的年  2022
console.log(date.getMonth() + 1) // 月份 返回的月份小1个月   记得月份+1 呦
console.log(date.getDate()) // 返回的是 几号
console.log(date.getDay()) // 5  周一返回的是 1 周六返回的是 6 但是 周日返回的是 0
```

- 实例

```javascript
// 输出2022年5月27日 星期五
var year = date.getFullYear()
var month = date.getMonth() + 1
var dates = date.getDate()
var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']
var day = date.getDay()
console.log(
  '今天是:' + year + '年' + month + '月' + dates + '日' + '\t' + arr[day]
)
```

#### 格式化日期时分秒

```javascript
var date = new Date()
console.log(date.getHours()) // 时
console.log(date.getMinutes()) // 分
console.log(date.getSeconds()) // 秒
```

- 实例

```javascript
// 要求封装一个函数返回当前的时分秒 格式 08:08:08
function getTime() {
  var time = new Date()
  var h = time.getHours()
  var m = time.getMinutes()
  var s = time.getSeconds()
  h = h < 10 ? '0' + h : h //补0方法
  m = m < 10 ? '0' + m : m
  s = s < 10 ? '0' + s : s
  return h + ':' + m + ':' + s
}
console.log(getTime())
```

#### 获得 Date 总的毫秒数

- 获得 Date 总的毫秒数(时间戳) 不是当前时间的毫秒数 而是距离 1970 年 1 月 1 号过了多少毫秒数

> 通过 valueOf() getTime()

```javascript
var date = new Date()
console.log(date.valueOf()) // 就是 我们现在时间 距离1970.1.1 总的毫秒数
console.log(date.getTime())
```

> 简单的写法 (最常用的写法)

```javascript
var date1 = +new Date() // +new Date()  返回的就是总的毫秒数
console.log(date1)
```

> H5 新增的 获得总的毫秒数

```javascript
console.log(Date.now())
```

#### 倒计时案例

```javascript
// 1.核心算法：输入的时间减去现在的时间就是剩余的时间，即倒计时 ，但是不能拿着时分秒相减，比如 05 分减去25分，结果会是负数的。
// 2.用时间戳来做。用户输入时间总的毫秒数减去现在时间的总的毫秒数，得到的就是剩余时间的毫秒数。
// 3.把剩余时间总的毫秒数转换为天、时、分、秒 （时间戳转换为时分秒）
// 转换公式如下：
//  d = parseInt(总秒数/ 60/60 /24);    //  计算天数
//  h = parseInt(总秒数/ 60/60 %24)   //   计算小时
//  m = parseInt(总秒数 /60 %60 );     //   计算分数
//  s = parseInt(总秒数%60);            //   计算当前秒数
function countDown(time) {
  var nowTime = +new Date() //返回当前时间总的毫秒数
  var inputTime = +new Date(time) //返回用户输入时间总毫秒数
  var times = (inputTime - nowTime) / 1000 //剩余时间总的毫秒数/1000 = 总秒数
  var d = parseInt(times / 60 / 60 / 24) //  计算天数
  d = d < 10 ? '0' + d : d
  var h = parseInt((times / 60 / 60) % 24) //   计算小时
  h = h < 10 ? '0' + h : h //补0方法
  var m = parseInt((times / 60) % 60) //   计算分数
  m = m < 10 ? '0' + m : m
  var s = parseInt(times % 60) //   计算当前秒数
  s = s < 10 ? '0' + s : s
  return d + '天' + h + '时' + m + '分' + s + '秒'
}
console.log(countDown('2022-05-31 24:00:00'))
```

### 数组对象

#### 创建数组方式

- 字面量

```javascript
var arr = [1, 2, 3]
console.log(arr[0])
```

- new array()

```javascript
var arr1 = new Array() //创建空数组
```

```javascript
var arr1 = new Array(2) // 这个2 表示 数组的长度为 2  里面有2个空的数组元素
```

```javascript
var arr1 = new Array(2, 3) // 等价于 [2,3]  这样写表示 里面有2个数组元素 是 2和3
```

#### 检测是否为数组

- instanceof 运算符 它可以用来检测是否为数组

```javascript
var arr = []
var obj = {}
console.log(arr instanceof Array) //true
console.log(obj instanceof Array) //false
```

- Array.isArray(参数); H5 新增的方法 ie9 以上版本支持

```javascript
console.log(Array.isArray(arr)) //true
console.log(Array.isArray(obj)) //false
```

- 案例【翻转数组】

```javascript
function reverse(arr) {
  // if (arr instanceof Array) {//添加数组判断 在进行后续翻转
  if (Array.isArray(arr)) {
    var newArr = []
    for (var i = arr.length - 1; i >= 0; i--) {
      newArr[newArr.length] = arr[i]
    }
    return newArr
  } else {
    return 'error 这个参数要求必须是数组格式 [1,2,3]'
  }
}
console.log(reverse([1, 2, 3]))
console.log(reverse(1, 2, 3))
```

#### 添加删除数组元素方法

##### push()

- 在我们数组的末尾 添加一个或者多个数组元素

> push 是可以给数组追加新的元素
>
> push() 里参数直接写 数组元素就可以了
>
> push 完毕之后，返回的结果是 新数组的长度
>
> 原数组也会发生变化

```javascript
var arr = [1, 2, 3]
// arr.push(4, 'pink');
console.log(arr.push(4, 'pink'))

console.log(arr)
```

##### unshift()

- 在我们数组的开头 添加一个或者多个数组元素

> unshift 是可以给数组前面追加新的元素
>
> unshift() 参数直接写 数组元素就可以了
>
> unshift 完毕之后，返回的结果是 新数组的长度
>
> 原数组也会发生变化

```javascript
console.log(arr.unshift('red', 'purple'))
console.log(arr)
```

##### pop()

- 它可以删除数组的最后一个元素

> pop 是可以删除数组的最后一个元素 记住一次只能删除一个元素
>
> pop() 没有参数
>
> pop 完毕之后，**返回的结果是 删除的那个元素**
>
> 原数组也会发生变化

```javascript
console.log(arr.pop())
console.log(arr)
```

##### shift()

- 它可以删除数组的第一个元素

> shift 是可以删除数组的第一个元素 记住一次只能删除一个元素
>
> shift() 没有参数
>
> shift 完毕之后，**返回的结果是 删除的那个元素**
>
> 原数组也会发生变化

```javascript
console.log(arr.shift())
console.log(arr)
```

#### 案例：筛选数组

- 有一个包含工资的数组[1500, 1200, 2000, 2100, 1800]，要求把数组中工资超过 2000 的删除，剩余的放到新数组里面

```javascript
var arr = [1500, 1200, 2000, 2100, 1800]
var newArr = []
for (var i = 0; i < arr.length; i++) {
  if (arr[i] < 2000) {
    //newArr[newArr.length] = arr[i];
    newArr.push(arr[i])
  }
}
console.log(newArr)
```

#### 数组排序

##### 翻转数组

```javascript
var arr = ['pink', 'red', 'blue']
arr.reverse()
console.log(arr)
```

##### 冒泡排序

```javascript
var arr1 = [13, 4, 77, 1, 7]
arr1.sort(function (a, b) {
  //  return a - b; 升序的顺序排列
  return b - a // 降序的顺序排列
})
console.log(arr1)
```

#### 获取数组元素索引方法

##### indexOf

> 回数组元素索引号方法 indexOf(数组元素) 作用就是返回该数组元素的索引号 从前面开始查找
>
> 它只返回第一个满足条件的索引号
>
> 它如果在该数组里面找不到元素，则返回的是 -1

```javascript
//var arr = ['red', 'green', 'blue', 'pink', 'blue'];
var arr = ['red', 'green', 'pink']
console.log(arr.indexOf('blue')) //-1
```

##### lastIndexOf

> 返回数组元素索引号方法 lastIndexOf(数组元素) 作用就是返回该数组元素的索引号 从后面开始查找

```javascript
var arr = ['red', 'green', 'blue', 'pink', 'blue']
console.log(arr.lastIndexOf('blue')) // 4
```

#### 数组去重

```javascript
// 数组去重 ['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'] 要求去除数组中重复的元素。
// 1.目标： 把旧数组里面不重复的元素选取出来放到新数组中， 重复的元素只保留一个， 放到新数组中去重。
// 2.核心算法： 我们遍历旧数组， 然后拿着旧数组元素去查询新数组， 如果该元素在新数组里面没有出现过， 我们就添加， 否则不添加。
// 3.我们怎么知道该元素没有存在？ 利用 新数组.indexOf(数组元素) 如果返回时 - 1 就说明 新数组里面没有改元素
// 封装一个 去重的函数 unique 独一无二的
function unique(arr) {
  var newArr = []
  for (var i = 0; i < arr.length; i++) {
    if (newArr.indexOf(arr[i]) === -1) {
      newArr.push(arr[i])
    }
  }
  return newArr
}
var demo = unique(['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'])
// var demo = unique(['blue', 'green', 'blue'])
console.log(demo)
```

#### 数组转换为字符串

##### toString()

```javascript
var arr = [1, 2, 3]
console.log(arr.toString()) // 1,2,3
```

##### join(分隔符)

```javascript
var arr1 = ['green', 'blue', 'pink']
console.log(arr1.join()) // green,blue,pink
console.log(arr1.join('-')) // green-blue-pink
console.log(arr1.join('&')) // green&blue&pink
```

#### 连接数组

##### concat()

> 返回值 返回一个新数组

```javascript
//concat()
var arr1 = ['pink', 'blue', 'red']
var arr2 = [1, 2, 3, 55, 66]
var nums = arr1.concat(arr2)
console.log(nums) //生成新数组
console.log(arr1) //原数组不变
```

#### 数组截取

##### slice(begin,end)

> 返回被截取项目的新数组

```javascript
//slice()  包头不包尾
var colors = ['red', 'black', 'pink', 'white', 'blue', 'purple']
console.log(colors.slice(0, 2)) //['red', 'black']
console.log(colors.slice(-1)) //['purple']
console.log(colors.slice(2)) //['pink', 'white', 'blue', 'purple']
console.log(colors.slice())
```

#### 数组删除

##### splice()

> 第几个开始 要删除个数
>
> 返回被删除项目的新数组 这个影响原数组

```javascript
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon']
//var removed = myFish.splice(2, 0, "drum");//从索引 2 的位置开始删除 0 个元素，插入“drum”
// console.log(myFish);//['angel', 'clown', 'drum', 'mandarin', 'sturgeon']
// var removed = myFish.splice(3, 1);//从索引 3 的位置开始删除 1 个元素
// console.log(myFish);
// console.log(removed);//['sturgeon']
var removed = myFish.splice(-2, 1) //从索引 -2 的位置开始删除 1 个元素
console.log(myFish) //['angel', 'clown', 'sturgeon']
var removed = myFish.splice(2) //从索引 2 的位置开始删除所有元素
console.log(myFish) //["angel", "clown"]
```

### 字符串对象

#### 基本包装类型

> 将简单数据类型包含为复杂数据类型

```javascript
var str = 'andy'
console.log(str.length)
// 对象 才有 属性和方法   复杂数据类型才有 属性和方法
// 简单数据类型为什么会有length 属性呢？
// 基本包装类型：  就是把简单数据类型 包装成为了 复杂数据类型
// (1) 把简单数据类型包装为复杂数据类型
var temp = new String('andy')
// (2) 把临时变量的值 给 str
str = temp
// (3) 销毁这个临时变量
temp = null
```

#### 字符串的不可变性

```javascript
// 字符串的不可变性
var str = 'andy'
console.log(str)
str = 'red'
console.log(str)
// 因为我们字符串的不可变所以不要大量的拼接字符串
var str = ''
for (var i = 1; i <= 1000000000; i++) {
  str += i
}
console.log(str)
```

#### 根据字符返回位置

##### str.indexOf

```javascript
// 字符串对象  根据字符返回位置  str.indexOf('要查找的字符', [起始的位置])
var str = '改革春风吹满地，春天来了'
console.log(str.indexOf('春'))
console.log(str.indexOf('春', 3)) // 从索引号是 3的位置开始往后查找
```

##### 案例：返回字符位置

```javascript
// 查找字符串"abcoefoxyozzopp"中所有o出现的位置以及次数
// 核心算法：先查找第一个o出现的位置
// 然后 只要indexOf 返回的结果不是 -1 就继续往后查找
// 因为indexOf 只能查找到第一个，所以后面的查找，一定是当前索引加1，从而继续查找
var str = 'oabcoefoxyozzopp'
var index = str.indexOf('o')
var num = 0
// console.log(index);
while (index !== -1) {
  console.log(index)
  num++
  index = str.indexOf('o', index + 1)
}
console.log('o出现的次数是: ' + num)
```

#### 根据位置返回字符

##### charAt(index)

```javascript
// 根据位置返回字符
// 1. charAt(index) 根据位置返回字符
var str = 'andy'
console.log(str.charAt(3))
// 遍历所有的字符
for (var i = 0; i < str.length; i++) {
  console.log(str.charAt(i))
}
// 2. charCodeAt(index)  返回相应索引号的字符ASCII值 目的： 判断用户按下了那个键
console.log(str.charCodeAt(0)) // 97
// 3. str[index] H5 新增的
console.log(str[0]) // a
```

##### 案例：返回字符位置

```javascript
//  判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数。
// o.a = 1
// o.b = 1
// o.c = 1
// o.o = 4
// 核心算法：利用 charAt(） 遍历这个字符串
// 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1
// 遍历对象，得到最大值和该字符
var str = 'abcoefoxyozzopp'
var o = {}
for (var i = 0; i < str.length; i++) {
  var chars = str.charAt(i) // chars 是 字符串的每一个字符
  if (o[chars]) {
    // o[chars] 得到的是属性值
    o[chars]++
  } else {
    o[chars] = 1
  }
}
console.log(o)
// 2. 遍历对象
var max = 0
var ch = ''
for (var k in o) {
  // k 得到是 属性名
  // o[k] 得到的是属性值
  if (o[k] > max) {
    max = o[k]
    ch = k
  }
}
console.log(max)
console.log('最多的字符是' + ch)
```

#### 字符串操作方法

##### concat()

```javascript
var str = 'andy'
console.log(str.concat('red'))
```

##### substr()

> substr('截取的起始位置', '截取几个字符')

```javascript
var str1 = '改革春风吹满地'
console.log(str1.substr(2, 2)) // 第一个2 是索引号的2 从第几个开始  第二个2 是取几个字符
```

##### 替换字符 replace

```javascript
// 1. 替换字符 replace('被替换的字符', '替换为的字符')  它只会替换第一个字符
var str = 'andyandy'
console.log(str.replace('a', 'b'))
```

- 案例

```javascript
// 有一个字符串 'abcoefoxyozzopp'  要求把里面所有的 o 替换为 *
var str1 = 'abcoefoxyozzopp'
while (str1.indexOf('o') !== -1) {
  str1 = str1.replace('o', '*')
}
console.log(str1)
```

##### split('分隔符')

```javascript
// 2. 字符转换为数组 split('分隔符')    前面我们学过 join 把数组转换为字符串
var str2 = 'red, pink, blue'
console.log(str2.split(','))
var str3 = 'red&pink&blue'
console.log(str3.split('&'))
```

##### toUpperCase()

```javascript
//转换大写
const sentence = 'The quick brown fox jumps over the lazy dog.'
console.log(sentence.toUpperCase())
```

##### toLowerCase()

```javascript
//转换小写
console.log('ALPHABET'.toLowerCase())
```

- 作业

> 给定一个字符串，如：“abaasdffggghhjjkkgfddsssss3444343”，问题如下：

```javascript
// 1、 字符串的长度
var str = 'abaasdffggghhjjkkgfddsssss3444343'
console.log(str.length) //33
// 2、 取出指定位置的字符，如：0,3,5,9等
console.log(str.charAt(0), str.charAt(3), str.charAt(5), str.charAt(9))
// 3、 查找指定字符是否在以上字符串中存在，如：i，c ，b等
var index = str.indexOf('i') //str.indexOf(searchValue [, fromIndex])返回对应字符的索引值
if (index !== -1) {
  //若存在，index为对应索引值,不存在返回-1，因此这里用if条件判断
  console.log('存在')
} else {
  console.log('不存在') //不存在
}
// 4、 替换指定的字符，如：g替换为22,ss替换为b等操作方法

while (str.indexOf('g') !== -1) {
  var str = str.replace('g', '22')
}
console.log(str)

// 5、 截取指定开始位置到结束位置的字符串，如：取得1-5的字符串

console.log(str.substr(0, 5)) //abaas
// 6、 找出以上字符串中出现次数最多的字符和出现的次数
var str = 'abaasdffggghhjjkkgfddsssss3444343'
var o = {}
for (var i = 0; i < str.length; i++) {
  var chars = str.charAt(i) // chars 是 字符串的每一个字符
  if (o[chars]) {
    // o[chars] 得到的是属性值
    o[chars]++
  } else {
    o[chars] = 1
  }
}
console.log(o)
// 2. 遍历对象
var max = 0
var ch = ''
for (var k in o) {
  // k 得到是 属性名
  // o[k] 得到的是属性值
  if (o[k] > max) {
    max = o[k]
    ch = k
  }
}
console.log(max)
console.log('最多的字符是' + ch)
// 7、 遍历字符串，并将遍历出的字符两头添加符号“@”
var str = 'abaasdffggghhjjkkgfddsssss3444343'
var str = str.split('') //将字符串分割成字符串方法
var newStr = '' //创建空数组
for (var i = 0; i < str.length; i++) {
  //遍历
  var newChar = '@' + str[i] + '@' + ';'
  newStr += newChar //将newChar一个个字符串相连
}
console.log(newStr)
```

### 简单数据类型 null

```javascript
// 简单数据类型 null  返回的是一个空的对象  object
var timer = null
console.log(typeof timer)
// 如果有个变量我们以后打算存储为对象，暂时没想好放啥， 这个时候就给 null
// 1. 简单数据类型 是存放在栈里面 里面直接开辟一个空间存放的是值
// 2. 复杂数据类型 首先在栈里面存放地址 十六进制表示  然后这个地址指向堆里面的数据
```
